{"version":3,"sources":["webpack://jsdap/webpack/universalModuleDefinition","webpack://jsdap/webpack/bootstrap","webpack://jsdap/./lib/vbscript.js","webpack://jsdap/./lib/xdr.js","webpack://jsdap/./lib/parser.js","webpack://jsdap/./lib/jsdap.js"],"names":["root","factory","exports","module","define","amd","jsdap","window","t","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","default","object","property","prototype","hasOwnProperty","p","s","e","IE_HACK","document","write","length","writable","key","shl","a","b","readBits","buffer","start","offsetLeft","offsetRight","curByte","lastByte","diff","sum","decodeInt","data","bytes","signed","x","max","Math","pow","decodeFloat","precisionBits","exponentBits","bias","signal","exponent","significand","divisor","byteValue","startBit","mask","NaN","Infinity","getBuffer","Array","charCodeAt","dapUnpacker","xdrdata","daplet","this","_buf","_pos","type","toLowerCase","out","tmp","child","getValue","push","map","array","maps","mark","_unpack_uint32","struct","slice","shape","_unpack_bytes","_unpack_string","func","reshape","size","stop","count","_unpack_byte","padding","str","String","fromCharCode","_createClass","_possibleConstructorReturn","ReferenceError","_inherits","TypeError","create","constructor","setPrototypeOf","__proto__","_classCallCheck","atomicTypes","structures","IDENTIFIER_REGEX","pseudoSafeEval","test","replace","eval","contains","item","el","trim","ltrim","rtrim","dapType","attributes","simpleParser","input","stream","expr","regExp","RegExp","match","substr","Error","ddsParser","dds","_this","getPrototypeOf","dataset","consume","peek","declaration","_declaration","id","walk","includeParent","attr","_grid","_structure","_sequence","_base_declaration","baseType","dimensions","token","parseInt","grid","map_","sequence","structure","dasParser","das","_this2","_target","_attr_container","_attribute","_container","indexOf","names","split","target","_metadata","output","values","tokens","substring","_parser","_xdr","u","DapClient","arguments","_vbscript2","url","callback","binary","extraheaders","xml","XMLHttpRequest","ActiveXObject","open","overrideMimeType","setRequestHeader","onreadystatechange","readyState","BinaryToArray","responseBody","toArray","responseText","send","_applydata","proxyUrl","dods","splice","parse"],"mappings":"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","file":"jsdap.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"jsdap\"] = factory();\n\telse\n\t\troot[\"jsdap\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n","export default function(IE_HACK) {\n    if (IE_HACK)\n        document.write(\n            '<script type=\"text/vbscript\">\\n\\\n        Function BinaryToArray(Binary)\\n\\\n            Dim i\\n\\\n            ReDim byteArray(LenB(Binary))\\n\\\n            For i = 1 To LenB(Binary)\\n\\\n                byteArray(i-1) = AscB(MidB(Binary, i, 1))\\n\\\n            Next\\n\\\n            BinaryToArray = byteArray\\n\\\n        End Function\\n\\\n    </script>'\n        );\n}\n","// Lots of code from http://jsfromhell.com/classes/binary-parser\n//    Jonas Raoni Soares Silva\n//    http://jsfromhell.com/classes/binary-parser [v1.0]\n\n\"use strict\";\n\nconst END_OF_SEQUENCE = \"\\xa5\\x00\\x00\\x00\";\nconst START_OF_SEQUENCE = \"\\x5a\\x00\\x00\\x00\";\n\nexport class dapUnpacker {\n    constructor(xdrdata, daplet) {\n        this._buf = xdrdata;\n        this.daplet = daplet;\n        this._pos = 0;\n    }\n\n    getValue() {\n        let i = this._pos;\n        let type = this.daplet.type.toLowerCase();\n\n        if (type == \"structure\" || type == \"dataset\") {\n            let out = [],\n                tmp;\n            let daplet = this.daplet;\n            for (let child in daplet) {\n                if (daplet[child].type) {\n                    this.daplet = daplet[child];\n                    tmp = this.getValue();\n                    out.push(tmp);\n                }\n            }\n            this.daplet = daplet;\n            return out;\n        } else if (type == \"grid\") {\n            let out = [],\n                tmp;\n            let daplet = this.daplet;\n\n            this.daplet = daplet.array;\n            tmp = this.getValue();\n            out.push(tmp);\n\n            for (let map in daplet.maps) {\n                this.daplet = daplet.maps[map];\n                tmp = this.getValue();\n                out.push(tmp);\n            }\n\n            this.daplet = daplet;\n            return out;\n        } else if (type == \"sequence\") {\n            let mark = this._unpack_uint32();\n            let out = [],\n                struct,\n                tmp;\n            let daplet = this.daplet;\n            while (mark != 2768240640) {\n                struct = [];\n                for (let child in daplet) {\n                    if (daplet[child].type) {\n                        this.daplet = daplet[child];\n                        tmp = this.getValue();\n                        struct.push(tmp);\n                    }\n                }\n                out.push(struct);\n                mark = this._unpack_uint32();\n            }\n            this.daplet = daplet;\n            return out;\n            // This is a request for a base type letiable inside a\n            // sequence.\n        } else if (this._buf.slice(i, i + 4) == START_OF_SEQUENCE) {\n            let mark = this._unpack_uint32();\n            let out = [],\n                tmp;\n            while (mark != 2768240640) {\n                tmp = this.getValue();\n                out.push(tmp);\n                mark = this._unpack_uint32();\n            }\n            return out;\n        }\n\n        let n = 1;\n        if (this.daplet.shape.length) {\n            n = this._unpack_uint32();\n            if (type != \"url\" && type != \"string\") {\n                this._unpack_uint32();\n            }\n        }\n\n        // Bytes?\n        let out;\n        if (type == \"byte\") {\n            out = this._unpack_bytes(n);\n            // String?\n        } else if (type == \"url\" || type == \"string\") {\n            out = this._unpack_string(n);\n        } else {\n            out = [];\n            let func;\n            switch (type) {\n                case \"float32\":\n                    func = \"_unpack_float32\";\n                    break;\n                case \"float64\":\n                    func = \"_unpack_float64\";\n                    break;\n                case \"int\":\n                    func = \"_unpack_int32\";\n                    break;\n                case \"uint\":\n                    func = \"_unpack_uint32\";\n                    break;\n                case \"int16\":\n                    func = \"_unpack_int16\";\n                    break;\n                case \"uint16\":\n                    func = \"_unpack_uint16\";\n                    break;\n                case \"int32\":\n                    func = \"_unpack_int32\";\n                    break;\n                case \"uint32\":\n                    func = \"_unpack_uint32\";\n                    break;\n            }\n            for (let i = 0; i < n; i++) {\n                out.push(this[func]());\n            }\n        }\n\n        if (this.daplet.shape) {\n            out = reshape(out, this.daplet.shape);\n        } else {\n            out = out[0];\n        }\n\n        return out;\n    }\n\n    _unpack_byte() {\n        let bytes = 1;\n        let signed = false;\n\n        let i = this._pos;\n        this._pos = i + bytes;\n        let data = this._buf.slice(i, i + bytes);\n        return decodeInt(data, bytes, signed);\n    }\n\n    _unpack_uint16() {\n        let bytes = 4;\n        let signed = false;\n\n        let i = this._pos;\n        this._pos = i + bytes;\n        let data = this._buf.slice(i, i + bytes);\n        return decodeInt(data, bytes, signed);\n    }\n\n    _unpack_uint32() {\n        let bytes = 4;\n        let signed = false;\n\n        let i = this._pos;\n        this._pos = i + bytes;\n        let data = this._buf.slice(i, i + bytes);\n        return decodeInt(data, bytes, signed);\n    }\n\n    _unpack_int16() {\n        let bytes = 4;\n        let signed = true;\n\n        let i = this._pos;\n        this._pos = i + bytes;\n        let data = this._buf.slice(i, i + bytes);\n        return decodeInt(data, bytes, signed);\n    }\n\n    _unpack_int32() {\n        let bytes = 4;\n        let signed = true;\n\n        let i = this._pos;\n        this._pos = i + bytes;\n        let data = this._buf.slice(i, i + bytes);\n        return decodeInt(data, bytes, signed);\n    }\n\n    _unpack_float32() {\n        let precision = 23;\n        let exponent = 8;\n        let bytes = 4;\n\n        let i = this._pos;\n        this._pos = i + bytes;\n        let data = this._buf.slice(i, i + bytes);\n        return decodeFloat(data, precision, exponent);\n    }\n\n    _unpack_float64() {\n        let precision = 52;\n        let exponent = 11;\n        let bytes = 8;\n\n        let i = this._pos;\n        this._pos = i + bytes;\n        let data = this._buf.slice(i, i + bytes);\n        return decodeFloat(data, precision, exponent);\n    }\n\n    _unpack_bytes(count) {\n        let i = this._pos;\n        let out = [];\n        for (let c = 0; c < count; c++) {\n            out.push(this._unpack_byte());\n        }\n        let padding = (4 - count % 4) % 4;\n        this._pos = i + count + padding;\n\n        return out;\n    }\n\n    _unpack_string(count) {\n        let out = [];\n        let n, i, j, data;\n        for (let c = 0; c < count; c++) {\n            n = this._unpack_uint32();\n            i = this._pos;\n            data = this._buf.slice(i, i + n);\n\n            let padding = (4 - n % 4) % 4;\n            this._pos = i + n + padding;\n\n            // convert back to string\n            let str = \"\";\n            for (let i = 0; i < n; i++) {\n                str += String.fromCharCode(data[i]);\n            }\n            out.push(str);\n        }\n\n        return out;\n    }\n}\n\nexport function getBuffer(data) {\n    let b = new Array(data.length);\n    for (let i = 0; i < data.length; i++) {\n        b[i] = data.charCodeAt(i) & 0xff;\n    }\n    return b;\n}\n\nfunction reshape(array, shape) {\n    if (!shape.length) return array[0];\n    let out = [];\n    let size, start, stop;\n    for (let i = 0; i < shape[0]; i++) {\n        size = array.length / shape[0];\n        start = i * size;\n        stop = start + size;\n        out.push(reshape(array.slice(start, stop), shape.slice(1)));\n    }\n    return out;\n}\n\nfunction shl(a, b) {\n    for (\n        ++b;\n        --b;\n        a = ((a %= 0x7fffffff + 1) & 0x40000000) == 0x40000000 ? a * 2 : (a - 0x40000000) * 2 + 0x7fffffff + 1\n    );\n    return a;\n}\n\nfunction readBits(buffer, start, length) {\n    let sum = 0;\n\n    if (start < 0 || length <= 0) return 0;\n\n    for (\n        let offsetLeft,\n            offsetRight = start % 8,\n            curByte = buffer.length - (start >> 3) - 1,\n            lastByte = buffer.length + (-(start + length) >> 3),\n            diff = curByte - lastByte,\n            sum =\n                ((buffer[curByte] >> offsetRight) & ((1 << (diff ? 8 - offsetRight : length)) - 1)) +\n                (diff && (offsetLeft = (start + length) % 8)\n                    ? (buffer[lastByte++] & ((1 << offsetLeft) - 1)) << ((diff-- << 3) - offsetRight)\n                    : 0);\n        diff;\n        sum += shl(buffer[lastByte++], (diff-- << 3) - offsetRight)\n    );\n    return sum;\n}\n\nfunction decodeInt(data, bytes, signed) {\n    let x = readBits(data, 0, bytes * 8);\n    let max = Math.pow(2, bytes * 8);\n    let integer;\n    if (signed && x >= max / 2) {\n        integer = x - max;\n    } else {\n        integer = x;\n    }\n    return integer;\n}\n\nfunction decodeFloat(data, precisionBits, exponentBits) {\n    let buffer = data;\n\n    let bias = Math.pow(2, exponentBits - 1) - 1;\n    let signal = readBits(buffer, precisionBits + exponentBits, 1);\n    let exponent = readBits(buffer, precisionBits, exponentBits);\n    let significand = 0;\n    let divisor = 2;\n    let curByte = buffer.length + (-precisionBits >> 3) - 1;\n    let byteValue, startBit, mask;\n\n    do\n        for (\n            byteValue = buffer[++curByte], startBit = precisionBits % 8 || 8, mask = 1 << startBit;\n            (mask >>= 1);\n            byteValue & mask && (significand += 1 / divisor), divisor *= 2\n        );\n    while ((precisionBits -= startBit));\n\n    return exponent == (bias << 1) + 1\n        ? significand ? NaN : signal ? -Infinity : +Infinity\n        : (1 + signal * -2) *\n              (exponent || significand\n                  ? !exponent ? Math.pow(2, -bias + 1) * significand : Math.pow(2, exponent - bias) * (1 + significand)\n                  : 0);\n}\n","\"use strict\";\n\nconst atomicTypes = [\n    \"byte\",\n    \"int\",\n    \"uint\",\n    \"int16\",\n    \"uint16\",\n    \"int32\",\n    \"uint32\",\n    \"float32\",\n    \"float64\",\n    \"string\",\n    \"url\",\n    \"alias\"\n];\nconst structures = [\"Sequence\", \"Structure\", \"Dataset\"];\nconst IDENTIFIER_REGEX = \"[\\\\w-/]\";\n\nArray.prototype.contains = item => {\n    for (let i = 0, el = this[i]; i < this.length; el = this[++i]) {\n        if (item == el) return true;\n    }\n    return false;\n};\n\nString.prototype.trim = () => {\n    return this.replace(/^\\s+|\\s+$/g, \"\");\n};\n\nString.prototype.ltrim = () => {\n    return this.replace(/^[\\s\\n\\r\\t]+/, \"\");\n};\n\nString.prototype.rtrim = () => {\n    return this.replace(/\\s+$/, \"\");\n};\n\nfunction pseudoSafeEval(str) {\n    if (/^[,:{}\\[\\]0-9.\\-+Eaeflnr-u \\n\\r\\t]*$/.test(str.replace(/\\\\./g, \"@\").replace(/\"[^\"\\\\\\n\\r]*\"/g, \"\"))) {\n        return eval(\"(\" + str + \")\");\n    }\n    return str;\n}\n\nclass dapType {\n    constructor(type) {\n        this.type = type;\n        this.attributes = {};\n    }\n}\n\nclass simpleParser {\n    constructor(input) {\n        this.stream = input;\n    }\n\n    peek(expr) {\n        let regExp = new RegExp(\"^\" + expr, \"i\");\n        let m = this.stream.match(regExp);\n        if (m) {\n            return m[0];\n        } else {\n            return \"\";\n        }\n    }\n\n    consume(expr) {\n        let regExp = new RegExp(\"^\" + expr, \"i\");\n        let m = this.stream.match(regExp);\n        if (m) {\n            this.stream = this.stream.substr(m[0].length).ltrim();\n            return m[0];\n        } else {\n            throw new Error(\"Unable to parse stream: \" + this.stream.substr(0, 10));\n        }\n    }\n}\n\nexport class ddsParser extends simpleParser {\n    constructor(dds) {\n        super(dds);\n        this.dds = dds;\n    }\n\n    parse() {\n        let dataset = new dapType(\"Dataset\");\n\n        this.consume(\"dataset\");\n        this.consume(\"{\");\n        while (!this.peek(\"}\")) {\n            let declaration = this._declaration();\n            dataset[declaration.name] = declaration;\n        }\n        this.consume(\"}\");\n\n        dataset.id = dataset.name = this.consume(\"[^;]+\");\n        this.consume(\";\");\n\n        // Set id.\n        function walk(daplet, includeParent) {\n            for (let attr in daplet) {\n                let child = daplet[attr];\n                if (child.type) {\n                    child.id = child.name;\n                    if (includeParent) {\n                        child.id = daplet.id + \".\" + child.id;\n                    }\n                    walk(child, true);\n                }\n            }\n        }\n\n        walk(dataset, false);\n\n        return dataset;\n    }\n\n    _declaration() {\n        let type = this.peek(IDENTIFIER_REGEX + \"+\").toLowerCase();\n        switch (type) {\n            case \"grid\":\n                return this._grid();\n            case \"structure\":\n                return this._structure();\n            case \"sequence\":\n                return this._sequence();\n            default:\n                return this._base_declaration();\n        }\n    }\n\n    _base_declaration() {\n        let baseType = new dapType();\n\n        baseType.type = this.consume(IDENTIFIER_REGEX + \"+\");\n        baseType.name = this.consume(IDENTIFIER_REGEX + \"+\");\n\n        baseType.dimensions = [];\n        baseType.shape = [];\n        while (!this.peek(\";\")) {\n            this.consume(\"\\\\[\");\n            let token = this.consume(IDENTIFIER_REGEX + \"+\");\n            if (this.peek(\"=\")) {\n                baseType.dimensions.push(token);\n                this.consume(\"=\");\n                let token = this.consume(\"\\\\d+\");\n            }\n            baseType.shape.push(parseInt(token));\n            this.consume(\"\\\\]\");\n        }\n        this.consume(\";\");\n\n        return baseType;\n    }\n\n    _grid() {\n        let grid = new dapType(\"Grid\");\n\n        this.consume(\"grid\");\n        this.consume(\"{\");\n\n        this.consume(\"array\");\n        this.consume(\":\");\n        grid.array = this._base_declaration();\n\n        this.consume(\"maps\");\n        this.consume(\":\");\n        grid.maps = {};\n        while (!this.peek(\"}\")) {\n            let map_ = this._base_declaration();\n            grid.maps[map_.name] = map_;\n        }\n        this.consume(\"}\");\n\n        grid.name = this.consume(IDENTIFIER_REGEX + \"+\");\n        this.consume(\";\");\n\n        return grid;\n    }\n\n    _sequence() {\n        let sequence = new dapType(\"Sequence\");\n\n        this.consume(\"sequence\");\n        this.consume(\"{\");\n        while (!this.peek(\"}\")) {\n            let declaration = this._declaration();\n            sequence[declaration.name] = declaration;\n        }\n        this.consume(\"}\");\n\n        sequence.name = this.consume(IDENTIFIER_REGEX + \"+\");\n        this.consume(\";\");\n\n        return sequence;\n    }\n\n    _structure() {\n        let structure = new dapType(\"Structure\");\n\n        this.consume(\"structure\");\n        this.consume(\"{\");\n        while (!this.peek(\"}\")) {\n            let declaration = this._declaration();\n            structure[declaration.name] = declaration;\n        }\n        this.consume(\"}\");\n\n        structure.name = this.consume(IDENTIFIER_REGEX + \"+\");\n\n        structure.dimensions = [];\n        structure.shape = [];\n        while (!this.peek(\";\")) {\n            this.consume(\"\\\\[\");\n            let token = this.consume(IDENTIFIER_REGEX + \"+\");\n            if (this.peek(\"=\")) {\n                structure.dimensions.push(token);\n                this.consume(\"=\");\n                token = this.consume(\"\\\\d+\");\n            }\n            structure.shape.push(parseInt(token));\n            this.consume(\"\\\\]\");\n        }\n\n        this.consume(\";\");\n\n        return structure;\n    }\n}\n\nexport class dasParser extends simpleParser {\n    constructor(das, dataset) {\n        super(das);\n        this.das = das;\n        this.dataset = dataset;\n    }\n\n    parse() {\n        this._target = this.dataset;\n\n        this.consume(\"attributes\");\n        this.consume(\"{\");\n        while (!this.peek(\"}\")) {\n            this._attr_container();\n        }\n        this.consume(\"}\");\n\n        return this.dataset;\n    }\n\n    _attr_container() {\n        if (atomicTypes.contains(this.peek(IDENTIFIER_REGEX + \"+\").toLowerCase())) {\n            this._attribute(this._target.attributes);\n\n            if (this._target.type == \"Grid\") {\n                for (let map in this._target.maps) {\n                    if (this.dataset[map]) {\n                        let map = this._target.maps[map];\n                        for (let name in map.attributes) {\n                            this.dataset[map].attributes[name] = map.attributes[name];\n                        }\n                    }\n                }\n            }\n        } else {\n            this._container();\n        }\n    }\n\n    _container() {\n        let name = this.consume(\"[\\\\w-_\\\\./]+\");\n        this.consume(\"{\");\n\n        if (name.indexOf(\".\") > -1) {\n            let names = name.split(\".\");\n            let target = this._target;\n            for (let i = 0; i < names.length; i++) {\n                this._target = this._target[names[i]];\n            }\n\n            while (!this.peek(\"}\")) {\n                this._attr_container();\n            }\n            this.consume(\"}\");\n\n            this._target = target;\n        } else if (structures.contains(this._target.type) && this._target[name]) {\n            let target = this._target;\n            this._target = target[name];\n\n            while (!this.peek(\"}\")) {\n                this._attr_container();\n            }\n            this.consume(\"}\");\n\n            this._target = target;\n        } else {\n            this._target.attributes[name] = this._metadata();\n            this.consume(\"}\");\n        }\n    }\n\n    _metadata() {\n        let output = {};\n        while (!this.peek(\"}\")) {\n            if (atomicTypes.contains(this.peek(IDENTIFIER_REGEX + \"+\").toLowerCase())) {\n                this._attribute(output);\n            } else {\n                let name = this.consume(IDENTIFIER_REGEX + \"+\");\n                this.consume(\"{\");\n                output[name] = this._metadata();\n                this.consume(\"}\");\n            }\n        }\n        return output;\n    }\n\n    _attribute(object) {\n        let type = this.consume(IDENTIFIER_REGEX + \"+\");\n        let name = this.consume(IDENTIFIER_REGEX + \"+\");\n\n        let values = [];\n        while (!this.peek(\";\")) {\n            let value = this.consume('\".*?[^\\\\\\\\]\"|[^;,]+');\n\n            if (type.toLowerCase() == \"string\" || type.toLowerCase() == \"url\") {\n                value = pseudoSafeEval(value);\n            } else if (type.toLowerCase() == \"alias\") {\n                let target, tokens;\n                if (value.match(/^\\\\./)) {\n                    tokens = value.substring(1).split(\".\");\n                    target = this.dataset;\n                } else {\n                    tokens = value.split(\".\");\n                    target = this._target;\n                }\n\n                for (let i = 0; i < tokens.length; i++) {\n                    let token = tokens[i];\n                    if (target[token]) {\n                        target = target[token];\n                    } else if (target.array.name == token) {\n                        target = target.array;\n                    } else if (target.maps[token]) {\n                        target = target.maps[token];\n                    } else {\n                        target = target.attributes[token];\n                    }\n                    value = target;\n                }\n            } else {\n                if (value.toLowerCase() == \"nan\") {\n                    value = NaN;\n                } else {\n                    value = pseudoSafeEval(value);\n                }\n            }\n            values.push(value);\n            if (this.peek(\",\")) {\n                this.consume(\",\");\n            }\n        }\n        this.consume(\";\");\n\n        if (values.length == 1) {\n            values = values[0];\n        }\n\n        object[name] = values;\n    }\n}\n","\"use strict\";\n\nimport { ddsParser, dasParser } from \"./parser.js\";\nimport { getBuffer, dapUnpacker } from \"./xdr.js\";\nimport ieHack from \"./vbscript.js\";\n\nexport class DapClient {\n    constructor(IE_HACK = false) {\n        this.IE_HACK = IE_HACK;\n        ieHack(this.IE_HACK);\n    }\n\n    proxyUrl(url, callback, binary, extraheaders) {\n        let xml = undefined;\n\n        // Mozilla/Safari/IE7+\n        if (window.XMLHttpRequest) {\n            xml = new XMLHttpRequest();\n            // IE6\n        } else if (window.ActiveXObject) {\n            xml = new window.ActiveXObject(\"Microsoft.XMLHTTP\");\n        }\n\n        xml.open(\"GET\", url, true);\n        if (xml.overrideMimeType) {\n            xml.overrideMimeType(\"text/plain; charset=x-user-defined\");\n        } else {\n            xml.setRequestHeader(\"Accept-Charset\", \"x-user-defined\");\n        }\n        if (extraheaders) {\n            for (let key in extraheaders) {\n                xml.setRequestHeader(key, extraheaders[key]);\n            }\n        }\n\n        xml.onreadystatechange = function() {\n            if (xml.readyState == 4) {\n                if (!binary) {\n                    callback(xml.responseText);\n                } else if (this.IE_HACK) {\n                    callback(BinaryToArray(xml.responseBody).toArray());\n                } else {\n                    callback(getBuffer(xml.responseText));\n                }\n            }\n        };\n        xml.send(\"\");\n    }\n\n    /** Flatten the data array as data attributes of elements of daplet */\n    _applydata(data, daplet) {\n        let i = 0;\n        for (let child in daplet) {\n            if (!daplet[child].type) continue;\n            daplet[child].data = data[i++];\n            if (daplet[child].type == \"Structure\") {\n                this._applydata(daplet[child].data, daplet[child]);\n            }\n        }\n    }\n\n    /**\n     * Load the dataset and call the callback with (data) where data is an array of data\n     * the url must be a url with .dods extension.\n     * @params:\n     * - url (string): the url (must be a .dods url, it might have additonnal slicing OpENDAP query string)\n     * - callback (function(data)): the callback which will receive parsed data.\n     * - extraheaders (map/object) : Javascript Object or map that contains keys and values of additonnal headers for the request.\n     */\n    loadData(url, callback, extraheaders) {\n        this.proxyUrl(\n            url,\n            function(dods) {\n                let dds = \"\";\n                while (!dds.match(/\\nData:\\n$/)) {\n                    let c = dods.splice(0, 1);\n                    if (c.length === 0) throw new Error(\"Error reading data, are you sur this is a .dods request ?\");\n                    dds += String.fromCharCode(c);\n                }\n                dds = dds.substr(0, dds.length - 7);\n\n                let daplet = new ddsParser(dds).parse();\n                let data = new dapUnpacker(dods, daplet).getValue();\n                this._applydata(data, daplet);\n                callback(daplet);\n            },\n            true,\n            extraheaders\n        );\n    }\n\n    /**\n     * Load the dataset and call the callback with (dataset) where dataset is the dataset \"metadata\";\n     * - url (string): the url (must be a bare OPeNDAP url, without \"format extension\" nor query parameters).\n     * - callback (function(data)): the callback which will receive parsed data.\n     * - extraheaders (map/object) : Javascript Object or map that contains keys and values of additonnal headers for the request.\n     */\n    loadDataset(url, callback, extraheaders) {\n        // Load DDS.\n        this.proxyUrl(\n            url + \".dds\",\n            function(dds) {\n                let dataset = new ddsParser(dds).parse();\n\n                // Load DAS.\n                this.proxyUrl(\n                    url + \".das\",\n                    function(das) {\n                        dataset = new dasParser(das, dataset).parse();\n                        callback(dataset);\n                    },\n                    false,\n                    extraheaders\n                );\n            },\n            false,\n            extraheaders\n        );\n    }\n}\n"],"sourceRoot":""}